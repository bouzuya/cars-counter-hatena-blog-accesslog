// Generated by CoffeeScript 1.10.0
(function() {
  var Client, FormData, Promise, cheerio, fetch;

  Promise = require('es6-promise').Promise;

  cheerio = require('cheerio');

  fetch = require('node-fetch');

  FormData = require('form-data');

  Client = (function() {
    function Client(arg) {
      var domain, password, username;
      username = arg.username, password = arg.password, domain = arg.domain;
      this._username = username;
      this._password = password;
      this._domain = domain;
      this._cookies = null;
    }

    Client.prototype.fetch = function() {
      return this._headers().then((function(_this) {
        return function(headers) {
          var url;
          url = "http://blog.hatena.ne.jp/" + _this._username + "/" + _this._domain + "/accesslog";
          return fetch(url, {
            headers: headers
          });
        };
      })(this)).then(function(res) {
        return res.text();
      }).then(function(html) {
        var $, $counts, monthly, today, total, weekly;
        $ = cheerio.load(html);
        $counts = $('#admin-main tr.count td');
        today = parseInt($counts.eq(0).text(), 10);
        weekly = parseInt($counts.eq(1).text(), 10);
        monthly = parseInt($counts.eq(2).text(), 10);
        total = parseInt($counts.eq(3).text(), 10);
        return {
          today: today,
          weekly: weekly,
          monthly: monthly,
          total: total
        };
      });
    };

    Client.prototype._login = function() {
      var form, password, url, username;
      username = this._username;
      password = this._password;
      url = 'https://www.hatena.ne.jp/login';
      form = new FormData();
      form.append('name', username);
      form.append('password', password);
      return fetch(url, {
        method: 'POST',
        body: form
      }).then(function(res) {
        return res.headers.getAll('set-cookie');
      }).then(function(cookies) {
        var parsed;
        parsed = {};
        cookies.forEach(function(cookie) {
          var pattern;
          pattern = new RegExp('\\s*;\\s*');
          return cookie.split(pattern).forEach(function(i) {
            var encodedKey, encodedValue, key, ref, value;
            ref = i.split('='), encodedKey = ref[0], encodedValue = ref[1];
            key = decodeURIComponent(encodedKey);
            value = decodeURIComponent(encodedValue);
            return parsed[key] = value;
          }, {});
        });
        return parsed;
      }).then((function(_this) {
        return function(parsed) {
          return _this._cookies = parsed;
        };
      })(this));
    };

    Client.prototype._headers = function() {
      var promise;
      promise = this._cookies != null ? Promise.resolve() : this._login();
      return promise.then((function(_this) {
        return function() {
          return {
            cookie: 'b=' + _this._cookies['b'] + ';rk=' + _this._cookies['rk']
          };
        };
      })(this));
    };

    return Client;

  })();

  module.exports = function(callback) {
    var client, domain, error, error1, password, username;
    try {
      username = process.env.HATENA_USERNAME;
      password = process.env.HATENA_PASSWORD;
      domain = process.env.HATENA_BLOG_DOMAIN;
      if (username == null) {
        return callback(new Error('HATENA_USERNAME is blank'));
      }
      if (password == null) {
        return callback(new Error('HATENA_PASSWORD is blank'));
      }
      if (domain == null) {
        return callback(new Error('HATENA_BLOG_DOMAIN is blank'));
      }
      client = new Client({
        username: username,
        password: password,
        domain: domain
      });
      return client.fetch().then(function(arg) {
        var counts, monthly, today, total, weekly;
        today = arg.today, weekly = arg.weekly, monthly = arg.monthly, total = arg.total;
        counts = {
          'hatena-blog-today': today,
          'hatena-blog-weekly': weekly,
          'hatena-blog-monthly': monthly,
          'hatena-blog-total': total
        };
        return callback(null, counts);
      })["catch"](function(error) {
        return callback(error);
      });
    } catch (error1) {
      error = error1;
      return callback(error);
    }
  };

}).call(this);
